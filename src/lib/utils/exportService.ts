import type { Notebook } from "../types/notebook";
import { serializeNotebook } from "./notebookFormat";

export interface ExportOptions {
  includeCode: boolean;
  includeOutputs: boolean;
  includeTimestamps: boolean;
  theme: "light" | "dark";
  format: "html" | "html-inline" | "pdf" | "js";
}

export class ExportService {
  async exportNotebook(
    notebook: Notebook,
    options: ExportOptions,
  ): Promise<string | Blob> {
    switch (options.format) {
      case "html":
        return this.exportToHTML(notebook, options);
      case "html-inline":
        return this.exportToHTMLInline(notebook, options);
      case "pdf":
        return this.exportToPDF(notebook, options);
      case "js":
        return serializeNotebook(notebook);
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }
  }

  private async exportToHTML(
    notebook: Notebook,
    options: ExportOptions,
  ): Promise<string> {
    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${notebook.name || "Untitled Notebook"}</title>
    <style>
        ${this.getHTMLStyles(options.theme)}
    </style>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism${
      options.theme === "dark" ? "-tomorrow" : ""
    }.css" rel="stylesheet">
</head>
<body>
    <div class="notebook-container">
        <header class="notebook-header">
            <h1>${notebook.name || "Untitled Notebook"}</h1>
            <div class="notebook-meta">
                <span>Created: ${
      new Date(notebook.createdAt).toLocaleDateString()
    }</span>
                <span>Modified: ${
      new Date(notebook.updatedAt).toLocaleDateString()
    }</span>
                <span>Cells: ${notebook.cells.length}</span>
            </div>
        </header>

        <main class="notebook-content">
            ${
      notebook.cells.map((cell, index) =>
        this.renderCellHTML(cell, index, options)
      ).join("")
    }
        </main>

        <footer class="notebook-footer">
            <p>Generated by Tangent Notebook on ${
      new Date().toLocaleString()
    }</p>
        </footer>
    </div>

    <script>
        // Initialize syntax highlighting
        Prism.highlightAll();

        // Make exported notebook interactive (optional)
        ${this.getInteractivityScript()}
    </script>
</body>
</html>`;

    return html;
  }

  /**
   * Export a self-contained HTML file that can replay the notebook outside of Tangent.
   * This builds a minimal bootstrap that:
   *  - embeds the notebook JSON,
   *  - loads per-cell modules (via jsdelivr ESM) if present,
   *  - executes cells in order, exposing top-level simple declarations on globalThis,
   *  - captures a last expression result for display.
   *
   * Notes:
   *  - This is an inline/replay approach (uses CDN for modules). For full offline/bundled export use a bundler.
   */
  private async exportToHTMLInline(
    notebook: Notebook,
    options: ExportOptions,
  ): Promise<string> {
    // Safely embed notebook JSON (avoid closing </script> issues)
    const notebookJson = JSON.stringify(notebook).replace(
      /<\/script/gi,
      "<\\/script",
    );

    const staticCells = notebook.cells.map((cell, index) =>
      this.renderCellHTML(
        cell as any,
        index,
        {
          includeCode: true,
          includeOutputs: true,
          includeTimestamps: false,
          theme: options.theme,
          format: "html",
        } as ExportOptions,
      )
    ).join("");

    const html = `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>${notebook.name || "Notebook (exported)"}</title>
  <style>${this.getHTMLStyles(options.theme)}</style>
</head>
<body>
  <div class="notebook-container">
    <header class="notebook-header">
      <h1>${this.escapeHTML(notebook.name || "Untitled Notebook")}</h1>
      <div class="notebook-meta">
        <span>Created: ${
      new Date(notebook.createdAt).toLocaleDateString()
    }</span>
        <span>Modified: ${
      new Date(notebook.updatedAt).toLocaleDateString()
    }</span>
        <span>Cells: ${notebook.cells.length}</span>
      </div>
    </header>

    <main id="notebook-content" class="notebook-content" style="margin-top:1rem;">${staticCells}</main>

    <footer class="notebook-footer" style="margin-top:2rem;">
      <p>Export generated by Tangent Notebook on ${
      new Date().toLocaleString()
    }</p>
    </footer>
  </div>

  <script>
    // Embedded notebook data
    const NOTEBOOK = ${notebookJson};

    // Minimal module loader that resolves spec to jsdelivr ESM URL when needed
    async function loadModuleSpec(spec) {
      try {
        if (/^https?:\\/\\//.test(spec)) {
          return await import(/* @vite-ignore */ spec);
        }
        const url = 'https://cdn.jsdelivr.net/npm/' + spec + '/+esm';
        return await import(/* @vite-ignore */ url);
      } catch (err) {
        throw new Error('Failed to load module ' + spec + ': ' + err.message);
      }
    }

    (async function replay() {
      const out = document.getElementById('notebook-content');
      if (!out) return;
      // simple util to show element
      function appendNode(node) { out.appendChild(node); }

      // keep existing static markup until replay completes successfully

      // cache loaded modules by spec
      window.__tn_loaded_modules = window.__tn_loaded_modules || {};

      for (let idx = 0; idx < (NOTEBOOK.cells || []).length; idx++) {
        const cell = NOTEBOOK.cells[idx];
        if (!cell) continue;

        // Markdown cell rendering
        if (cell.type !== 'code') {
          const md = document.createElement('div');
          md.className = 'cell cell-markdown';
          md.style.padding = '0.75rem';
          md.innerHTML = (cell.content || '').replace(/\\n/g, '<br>');
          appendNode(md);
          continue;
        }

        // Code cell container
        const cellWrapper = document.createElement('div');
        cellWrapper.className = 'cell cell-code';
        cellWrapper.style.padding = '0.5rem';
        cellWrapper.style.border = '1px solid #e6e6e6';
        cellWrapper.style.marginBottom = '0.75rem';
        appendNode(cellWrapper);

        // If the cell declares modules (optional), load them and expose to globalThis
        if (cell.modules && Array.isArray(cell.modules) && cell.modules.length) {
          const modInfo = document.createElement('div');
          modInfo.style.fontSize = '0.85rem';
          modInfo.style.color = '#6b7280';
          modInfo.textContent = 'Loading modules: ' + cell.modules.join(', ');
          cellWrapper.appendChild(modInfo);

          try {
            await Promise.all(cell.modules.map(async (m) => {
              if (!window.__tn_loaded_modules[m]) {
                const mod = await loadModuleSpec(m);
                // attach a sensible name on globalThis (heuristic)
                const name = m.split('@')[0].replace(/[^A-Za-z0-9_$]/g, '_') || m;
                window[name] = mod.default || mod;
                window.__tn_loaded_modules[m] = { name, spec: m };
              }
            }));
            modInfo.textContent = 'Modules loaded: ' + cell.modules.join(', ');
          } catch (err) {
            modInfo.textContent = 'Module load error: ' + err.message;
          }
        }

        // Execution area
        const outputDiv = document.createElement('div');
        outputDiv.className = 'cell-output';
        outputDiv.style.paddingTop = '0.5rem';
        cellWrapper.appendChild(outputDiv);

        // Prepare code execution:
        // - promote simple top-level declarations to globalThis.<name> so subsequent cells can use them
        // - capture a final expression into globalThis.__tn_last for display
        const original = cell.content || '';
        let code = original;

        // transform simple declarations like: const x = ...  -> globalThis.x = ...
        code = code.replace(/(^|\\n)\\s*(?:const|let|var)\\s+([A-Za-z_$][\\w$]*)\\s*=/g, '$1globalThis.$2 = ');

        // detect last-line expression (simple heuristic)
        const lines = (original || '').trim().split('\n');
        const lastLine = (lines[lines.length - 1] || '').trim();
        const lastWithoutSemicolon = lastLine.replace(/;+$/, '');
        const isExpr = lastWithoutSemicolon && !/^(const|let|var|function|class|if|for|while|switch|return)\b/.test(lastWithoutSemicolon) && !/\{$/.test(lastWithoutSemicolon);
        if (isExpr) {
          const before = lines.slice(0, -1).join('\n');
          // If the last expression is an assignment to globalThis/window, execute silently
          // (do not capture into __tn_last) to avoid dumping very large structures.
          const isAssignToGlobal = /^\s*(?:globalThis|window)\s*(?:\.|\[).*=/.test(lastWithoutSemicolon);
          if (isAssignToGlobal) {
            if (before.trim()) {
              code = before + '\n' + lastWithoutSemicolon + ';';
            } else {
              code = lastWithoutSemicolon + ';';
            }
          } else {
            const expr = lastWithoutSemicolon;
            if (before.trim()) {
              code = before + '\n' + 'globalThis.__tn_last = (' + expr + ');';
            } else {
              code = 'globalThis.__tn_last = (' + expr + ');';
            }
          }
        }

        try {
          // indirect eval to run in global scope so globalThis assignments persist
          (0, eval)(code);

          const last = globalThis.__tn_last;
          if (last instanceof Node) {
            outputDiv.appendChild(last);
          } else {
            const pre = document.createElement('pre');
            pre.style.margin = '0';
            pre.style.whiteSpace = 'pre-wrap';
            pre.style.wordBreak = 'break-word';
            pre.textContent = last !== undefined ? (typeof last === 'string' ? last : JSON.stringify(last, null, 2)) : 'Executed successfully';
            outputDiv.appendChild(pre);
          }
        } catch (err) {
          const pre = document.createElement('pre');
          pre.style.color = 'red';
          pre.textContent = String(err);
          outputDiv.appendChild(pre);
        } finally {
          try { delete globalThis.__tn_last; } catch (e) {}
        }
      } // end for cells
    })().catch(e => {
      const err = document.createElement('pre');
      err.style.color = 'red';
      err.textContent = String(e);
      document.body.appendChild(err);
    });
  </script>
</body>
</html>`;

    return html;
  }

  private renderCellHTML(
    cell: any,
    index: number,
    options: ExportOptions,
  ): string {
    const cellClass = `cell cell-${cell.type}`;
    let cellContent = "";

    if (cell.type === "code") {
      if (options.includeCode) {
        cellContent += `
          <div class="cell-input">
            <div class="cell-label">In [${index + 1}]:</div>
            <pre><code class="language-javascript">${
          this.escapeHTML(cell.content)
        }</code></pre>
          </div>
        `;
      }

      if (options.includeOutputs && cell.output) {
        cellContent += `
          <div class="cell-output">
            <div class="cell-label">Out [${index + 1}]:</div>
            <div class="output-content ${cell.output.type}">
              ${this.renderOutputHTML(cell.output)}
            </div>
            ${
          options.includeTimestamps
            ? `<div class="timestamp">${
              new Date(cell.output.timestamp).toLocaleTimeString()
            }</div>`
            : ""
        }
          </div>
        `;
      }
    } else if (cell.type === "markdown") {
      cellContent += `
        <div class="cell-markdown">
          ${this.renderMarkdownHTML(cell.content)}
        </div>
      `;
    }

    return `<div class="${cellClass}">${cellContent}</div>`;
  }

  private renderOutputHTML(output: any): string {
    switch (output.type) {
      case "html":
        return output.content;
      case "text":
        return `<pre class="text-output">${
          this.escapeHTML(output.content)
        }</pre>`;
      case "error":
        return `<pre class="error-output">${
          this.escapeHTML(output.content)
        }</pre>`;
      case "json":
        try {
          const parsed = typeof output.content === "string"
            ? JSON.parse(output.content)
            : output.content;
          return `<pre class="json-output"><code class="language-json">${
            this.escapeHTML(JSON.stringify(parsed, null, 2))
          }</code></pre>`;
        } catch {
          return `<pre class="json-output"><code class="language-json">${
            this.escapeHTML(String(output.content))
          }</code></pre>`;
        }
      case "dom":
        if (output.content && typeof (output.content as any).outerHTML === "string") {
          return (output.content as any).outerHTML;
        }
        return `<div class="dom-output">${
          this.escapeHTML(String(output.content ?? ""))
        }</div>`;
      default:
        return `<pre class="text-output">${
          this.escapeHTML(String(output.content))
        }</pre>`;
    }
  }

  private renderMarkdownHTML(markdown: string): string {
    // Simple markdown to HTML conversion
    // In a production app, you'd use a proper markdown parser like marked.js
    return markdown
      .replace(/^# (.*$)/gim, "<h1>$1</h1>")
      .replace(/^## (.*$)/gim, "<h2>$1</h2>")
      .replace(/^### (.*$)/gim, "<h3>$1</h3>")
      .replace(/\*\*(.*)\*\*/gim, "<strong>$1</strong>")
      .replace(/\*(.*)\*/gim, "<em>$1</em>")
      .replace(/\`(.*)\`/gim, "<code>$1</code>")
      .replace(/\n/gim, "<br>");
  }

  private getHTMLStyles(theme: "light" | "dark"): string {
    const baseStyles = `
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        line-height: 1.6;
        color: ${theme === "dark" ? "#e5e7eb" : "#374151"};
        background-color: ${theme === "dark" ? "#1f2937" : "#ffffff"};
      }

      .notebook-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
      }

      .notebook-header {
        border-bottom: 2px solid ${theme === "dark" ? "#374151" : "#e5e7eb"};
        padding-bottom: 1rem;
        margin-bottom: 2rem;
      }

      .notebook-header h1 {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
      }

      .notebook-meta {
        display: flex;
        gap: 1rem;
        font-size: 0.875rem;
        color: ${theme === "dark" ? "#9ca3af" : "#6b7280"};
      }

      .cell {
        margin-bottom: 2rem;
        border: 1px solid ${theme === "dark" ? "#374151" : "#e5e7eb"};
        border-radius: 0.5rem;
        overflow: hidden;
      }

      .cell-input, .cell-output {
        padding: 1rem;
      }

      .cell-input {
        background-color: ${theme === "dark" ? "#111827" : "#f9fafb"};
        border-bottom: 1px solid ${theme === "dark" ? "#374151" : "#e5e7eb"};
      }

      .cell-output {
        background-color: ${theme === "dark" ? "#1f2937" : "#ffffff"};
      }

      .cell-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: ${theme === "dark" ? "#60a5fa" : "#3b82f6"};
        margin-bottom: 0.5rem;
      }

      .cell-markdown {
        padding: 1rem;
        background-color: ${theme === "dark" ? "#1f2937" : "#ffffff"};
      }

      pre {
        background-color: ${theme === "dark" ? "#0f172a" : "#f1f5f9"};
        padding: 1rem;
        border-radius: 0.375rem;
        overflow-x: auto;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 0.875rem;
      }

      code {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 0.875rem;
      }

      .text-output {
        color: ${theme === "dark" ? "#e5e7eb" : "#374151"};
      }

      .error-output {
        color: ${theme === "dark" ? "#fca5a5" : "#dc2626"};
        background-color: ${theme === "dark" ? "#7f1d1d" : "#fef2f2"};
      }

      .json-output {
        color: ${theme === "dark" ? "#a78bfa" : "#7c3aed"};
      }

      .timestamp {
        font-size: 0.75rem;
        color: ${theme === "dark" ? "#9ca3af" : "#6b7280"};
        margin-top: 0.5rem;
      }

      table.tangent-table-output {
        width: 100%;
        border-collapse: collapse;
        font-family: 'Fira Code', 'Fira Sans', sans-serif;
        font-size: 0.75rem;
        line-height: 1.45;
        border: 1px solid ${theme === "dark" ? "#374151" : "#e5e7eb"};
        border-radius: 0.375rem;
        overflow: hidden;
      }

      table.tangent-table-output thead {
        background-color: ${theme === "dark" ? "#1f2937" : "#f4f5f7"};
      }

      table.tangent-table-output th,
      table.tangent-table-output td {
        border: 1px solid ${theme === "dark" ? "#374151" : "#eceef1"};
        padding: 0.35rem 0.6rem;
        text-align: right;
        white-space: nowrap;
      }

      table.tangent-table-output th {
        font-weight: 600;
        color: ${theme === "dark" ? "#f9fafb" : "#1f2933"};
        letter-spacing: 0.01em;
      }

      table.tangent-table-output tbody tr:nth-child(even) {
        background-color: ${theme === "dark" ? "#1f2531" : "#fafbfc"};
      }

      .notebook-footer {
        border-top: 1px solid ${theme === "dark" ? "#374151" : "#e5e7eb"};
        padding-top: 1rem;
        margin-top: 2rem;
        text-align: center;
        font-size: 0.875rem;
        color: ${theme === "dark" ? "#9ca3af" : "#6b7280"};
      }

      @media print {
        body { background: white; color: black; }
        .cell { break-inside: avoid; }
      }
    `;

    return baseStyles;
  }

  private getInteractivityScript(): string {
    return `
      // Add copy-to-clipboard functionality
      document.querySelectorAll('pre code').forEach(block => {
        const button = document.createElement('button');
        button.textContent = 'Copy';
        button.style.cssText = 'position: absolute; top: 0.5rem; right: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.75rem; background: #3b82f6; color: white; border: none; border-radius: 0.25rem; cursor: pointer;';

        const container = document.createElement('div');
        container.style.position = 'relative';
        block.parentNode.insertBefore(container, block);
        container.appendChild(block);
        container.appendChild(button);

        button.addEventListener('click', () => {
          navigator.clipboard.writeText(block.textContent).then(() => {
            button.textContent = 'Copied!';
            setTimeout(() => button.textContent = 'Copy', 2000);
          });
        });
      });
    `;
  }

  private async exportToPDF(
    notebook: Notebook,
    options: ExportOptions,
  ): Promise<Blob> {
    // Generate HTML first
    const html = await this.exportToHTML(notebook, options);

    // Use browser's print functionality to generate PDF
    // In a real application, you might use a library like Puppeteer or jsPDF
    return new Promise((resolve, reject) => {
      try {
        // Create a temporary iframe with the HTML content
        const iframe = document.createElement("iframe");
        iframe.style.position = "absolute";
        iframe.style.left = "-9999px";
        iframe.style.width = "8.5in";
        iframe.style.height = "11in";

        document.body.appendChild(iframe);

        const iframeDoc = iframe.contentDocument ||
          iframe.contentWindow?.document;
        if (!iframeDoc) {
          throw new Error("Could not access iframe document");
        }

        iframeDoc.open();
        iframeDoc.write(html);
        iframeDoc.close();

        // Wait for content to load
        setTimeout(() => {
          try {
            // Use the browser's print functionality
            iframe.contentWindow?.print();

            // Clean up
            document.body.removeChild(iframe);

            // Return a placeholder blob (in a real app, you'd capture the PDF)
            const pdfBlob = new Blob([html], { type: "application/pdf" });
            resolve(pdfBlob);
          } catch (error) {
            document.body.removeChild(iframe);
            reject(error);
          }
        }, 1000);
      } catch (error) {
        reject(error);
      }
    });
  }

  private escapeHTML(text: string): string {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // Utility method to download the exported content
  downloadFile(content: string | Blob, filename: string, mimeType: string) {
    const blob = typeof content === "string"
      ? new Blob([content], { type: mimeType })
      : content;

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Generate filename based on notebook title and current date
  generateFilename(notebook: Notebook, format: string): string {
    const title = notebook.name || "untitled_notebook";
    const sanitizedTitle = title.replace(/[^a-z0-9]/gi, "_").toLowerCase();
    const date = new Date().toISOString().split("T")[0];
    return `${sanitizedTitle}_${date}.${format}`;
  }
}

// Singleton instance
export const exportService = new ExportService();
